/* This file has been generated by the Hex-Rays decompiler.
   Copyright (c) 2009 Hex-Rays <info@hex-rays.com>

   Detected compiler: GNU C++
*/

#include <defs.h>


//-------------------------------------------------------------------------
// Data declarations

extern _UNKNOWN start; // weak
extern char format[3]; // idb
extern char a0xX[]; // idb
extern char asc_8049DC8[4]; // weak
extern char asc_8049DCC[]; // idb
extern char asc_8049DCF[4]; // weak
extern int ctors; // weak
extern int dtors[]; // weak
extern _UNKNOWN more_dtors; // weak
extern int dword_804BF24; // weak
extern int (__cdecl *vtable[8])(int); // weak
extern char program[]; // weak
extern int dword_806C0C0; // weak
extern FILE *stderr; // idb
extern FILE *stdin; // idb
extern char byte_806C0CC; // weak
extern int i; // weak
// extern _UNKNOWN _gmon_start__; weak

//-------------------------------------------------------------------------
// Function declarations

void (*__cdecl init_proc())(void);
int raise(int sig);
int __isoc99_fscanf(_DWORD, const char *, ...); // weak
int fflush(FILE *stream);
int __fastcall __stack_chk_fail(_DWORD, _DWORD); // weak
int __gmon_start__(void); // weak
int feof(FILE *stream);
int fprintf(FILE *stream, const char *format, ...);
int ungetc(int c, FILE *stream);
int fgetc(FILE *stream);
int fputc(int c, FILE *stream);
void __cdecl call_dtors();
int __cdecl ret0();
int __cdecl if_feof_segfault();
bool __cdecl chars_left();
int __cdecl deref(int a1);
bool __cdecl deref_nz(int a1);
int __cdecl deref_putc(int *a1);
int __cdecl read_int_to_ptr(int *a1);
int __cdecl read_hex_int_to_ptr(int *a1);
int __cdecl read_char();
int __cdecl read_int();
int __cdecl read_hex_int();
float __cdecl id_(float a1);
int __cdecl id(int a1);
int __cdecl deref_put_float(float *a1);
int __cdecl read_float_round();
int __cdecl deref_(int *a1);
signed int __cdecl id__(int *a1);
int __cdecl deref_add_next(int *a1);
int __cdecl deref_sub_next(int *a1);
int __cdecl deref_mul_next(int *a1);
int __cdecl deref_div_next(int *a1);
int __cdecl deref_add_10000_ret_old(int a1);
int __cdecl run_vm(int *arr0);
int __cdecl main();
int *__cdecl get_ctors();
void __cdecl deref_esp_to_ebx();
void (*__cdecl call_ctors())(void);
void __cdecl term_proc();


//----- (0804844C) --------------------------------------------------------
void (*__cdecl init_proc())(void)
{
  if ( &_gmon_start__ )
    __gmon_start__();
  ret0();
  return call_ctors();
}
// 80484D0: using guessed type int __gmon_start__(void);

//----- (08048540) --------------------------------------------------------
#error "8048543: positive sp value has been found (funcsize=2)"

//----- (08048570) --------------------------------------------------------
void __cdecl call_dtors()
{
  int v0; // eax@2
  int i; // ebx@2

  if ( !byte_806C0CC )
  {
    v0 = ::i;
    for ( i = ((&more_dtors - dtors) >> 2) - 1; ::i < i; v0 = ::i )
    {
      ::i = v0 + 1;
      (dtors[::i])();
    }
    byte_806C0CC = 1;
  }
}
// 804BF1C: using guessed type int dtors[];
// 806C0CC: using guessed type char byte_806C0CC;
// 806C0D0: using guessed type int i;

//----- (080485D0) --------------------------------------------------------
int __cdecl ret0()
{
  int result; // eax@1

  result = dword_804BF24;
  if ( dword_804BF24 )
    result = 0;
  return result;
}
// 804BF24: using guessed type int dword_804BF24;

//----- (080485F4) --------------------------------------------------------
int __cdecl if_feof_segfault()
{
  int result; // eax@1

  result = feof(stdin);
  if ( result )
    result = raise(11);
  return result;
}

//----- (08048619) --------------------------------------------------------
bool __cdecl chars_left()
{
  int call; // ST18_4@1
  bool chars_left; // ST1C_4@1

  call = fgetc(stdin);
  chars_left = feof(stdin) != 0;
  ungetc(call, stdin);
  return chars_left;
}

//----- (08048660) --------------------------------------------------------
int __cdecl deref(int a1)
{
  return *a1;
}

//----- (0804866A) --------------------------------------------------------
bool __cdecl deref_nz(int a1)
{
  return *a1 != 0;
}

//----- (0804867C) --------------------------------------------------------
int __cdecl deref_putc(int *a1)
{
  fputc(*a1, stderr);
  fflush(stderr);
  return *a1;
}

//----- (080486AD) --------------------------------------------------------
int __cdecl read_int_to_ptr(int *a1)
{
  return fprintf(stderr, "%d", *a1);
}

//----- (080486D4) --------------------------------------------------------
int __cdecl read_hex_int_to_ptr(int *a1)
{
  return fprintf(stderr, "0x%X", *a1);
}

//----- (080486FB) --------------------------------------------------------
int __cdecl read_char()
{
  if_feof_segfault();
  return fgetc(stdin);
}

//----- (0804871B) --------------------------------------------------------
int __cdecl read_int()
{
  int n; // [sp+1Ch] [bp-Ch]@1

  if_feof_segfault();
  __isoc99_fscanf(stdin, "%d", &n);
  return n;
}
// 80484A0: using guessed type int __isoc99_fscanf(_DWORD, const char *, ...);

//----- (0804874E) --------------------------------------------------------
int __cdecl read_hex_int()
{
  int v1; // [sp+1Ch] [bp-Ch]@1

  if_feof_segfault();
  __isoc99_fscanf(stdin, "%x ", &v1);
  return v1;
}
// 80484A0: using guessed type int __isoc99_fscanf(_DWORD, const char *, ...);

//----- (08048781) --------------------------------------------------------
float __cdecl id_(float a1)
{
  float v1; // st7@1

  *&v1 = a1;
  return v1;
}

//----- (08048798) --------------------------------------------------------
int __cdecl id(int a1)
{
  return a1;
}

//----- (080487A9) --------------------------------------------------------
int __cdecl deref_put_float(float *a1)
{
  float v2; // st7@1

  *&v2 = id_(*a1);
  return fprintf(stderr, "%f", *&v2);
}

//----- (080487D8) --------------------------------------------------------
int __cdecl read_float_round()
{
  int v1; // [sp+1Ch] [bp-Ch]@1

  if_feof_segfault();
  __isoc99_fscanf(stdin, "%f ", &v1);
  return id(v1);
}
// 80484A0: using guessed type int __isoc99_fscanf(_DWORD, const char *, ...);

//----- (08048813) --------------------------------------------------------
int __cdecl deref_(int *a1)
{
  int v2; // ST08_4@1

  *&v2 = *a1;
  return id(v2);
}

//----- (08048834) --------------------------------------------------------
signed int __cdecl id__(int *a1)
{
  return id_(COERCE_FLOAT(*a1));
}

//----- (0804887B) --------------------------------------------------------
int __cdecl deref_add_next(int *a1)
{
  long double v2; // fst6@1
  int v3; // ST10_4@1

  v2 = id_(*a1);
  *&v3 = id_(*(a1 + 1)) + v2;
  return id(v3);
}

//----- (080488B6) --------------------------------------------------------
int __cdecl deref_sub_next(int *a1)
{
  long double v2; // fst6@1
  int v3; // ST10_4@1

  v2 = id_(*a1);
  *&v3 = v2 - id_(*(a1 + 1));
  return id(v3);
}

//----- (080488F1) --------------------------------------------------------
int __cdecl deref_mul_next(int *a1)
{
  long double v2; // fst6@1
  int v3; // ST10_4@1

  v2 = id_(*a1);
  *&v3 = id_(*(a1 + 1)) * v2;
  return id(v3);
}

//----- (0804892C) --------------------------------------------------------
int __cdecl deref_div_next(int *a1)
{
  long double v2; // fst6@1
  int v3; // ST10_4@1

  v2 = id_(*a1);
  *&v3 = v2 / id_(*(a1 + 1));
  return id(v3);
}

//----- (08048967) --------------------------------------------------------
int __cdecl deref_add_10000_ret_old(int a1)
{
  int v2; // ST0C_4@1

  v2 = dword_806C0C0;
  dword_806C0C0 += *a1;
  return v2;
}
// 806C0C0: using guessed type int dword_806C0C0;

//----- (0804898B) --------------------------------------------------------
int __cdecl run_vm(int *arr0)
{
  int tmp1; // eax@129
  int tmp2; // eax@133
  int tmp3; // eax@137
  int tmp4; // eax@141
  int tmp5; // eax@145
  int tmp6; // eax@149
  char *tmp7; // eax@185
  int vm_mem[31]; // [sp+14h] [bp-B4h]@3
  int *something_p; // [sp+90h] [bp-38h]@9
  int vm_eip; // [sp+94h] [bp-34h]@1
  int i; // [sp+98h] [bp-30h]@2
  int j; // [sp+9Ch] [bp-2Ch]@6
  int result_value; // [sp+A0h] [bp-28h]@9
  int dest; // [sp+A4h] [bp-24h]@9
  struct operands ops; // [sp+A8h] [bp-20h]@9
  int op2; // [sp+B0h] [bp-18h]@9
  int v18; // [sp+B4h] [bp-14h]@9
  int op1; // [sp+B8h] [bp-10h]@9
  enum instr_flag flag; // [sp+BCh] [bp-Ch]@9

  vm_eip = 4096;
  if ( arr0 )
  {
    for ( i = 0; i <= 30; ++i )
      vm_mem[i] = arr0[i];
  }
  else
  {
    for ( j = 0; j <= 30; ++j )
      vm_mem[j] = 0;
  }
  something_p = 0xF000;
  result_value = 0;
  v18 = 0;
  op1 = 0;
  flag = 0;
  op2 = 0;
  ops = 0LL;
  dest = 0;
continue:
  while ( program[vm_eip] != ret )
  {
    switch ( program[vm_eip] )
    {
      case nop:
        ++vm_eip;
        goto continue;
      case 1:
        v18 = *(program + something_p);
        if ( !v18 )
          return vm_mem[0];
        ++something_p;
        vm_eip = v18;
        result_value = 0;
        break;
      case add:
        flag = program[vm_eip + 1];
        dest = program[vm_eip + 2];
        if ( flag == op1_is_ptr )
        {
          ops.op1 = vm_mem[program[vm_eip + 3]];
          ops.op2 = *&program[vm_eip + 4];
          vm_eip += 8;
        }
        else
        {
          if ( flag > op1_is_ptr )
          {
            if ( flag == op2_is_ptr )
            {
              ops.op1 = *&program[vm_eip + 3];
              ops.op2 = vm_mem[program[vm_eip + 7]];
              vm_eip += 8;
            }
            else
            {
              if ( flag == no_ptr )
              {
                ops.op1 = *&program[vm_eip + 3];
                ops.op2 = *&program[vm_eip + 7];
                vm_eip += 11;
              }
            }
          }
          else
          {
            if ( !flag )
            {
              ops.op1 = vm_mem[program[vm_eip + 3]];
              ops.op2 = vm_mem[program[vm_eip + 4]];
              vm_eip += 5;
            }
          }
        }
        vm_mem[dest] = ops.op2 + ops.op1;
        result_value = vm_mem[dest];
        goto continue;
      case minus:
        flag = program[vm_eip + 1];
        dest = program[vm_eip + 2];
        if ( flag == op1_is_ptr )
        {
          ops.op1 = vm_mem[program[vm_eip + 3]];
          ops.op2 = *&program[vm_eip + 4];
          vm_eip += 8;
        }
        else
        {
          if ( flag > op1_is_ptr )
          {
            if ( flag == op2_is_ptr )
            {
              ops.op1 = *&program[vm_eip + 3];
              ops.op2 = vm_mem[program[vm_eip + 7]];
              vm_eip += 8;
            }
            else
            {
              if ( flag == no_ptr )
              {
                ops.op1 = *&program[vm_eip + 3];
                ops.op2 = *&program[vm_eip + 7];
                vm_eip += 11;
              }
            }
          }
          else
          {
            if ( !flag )
            {
              ops.op1 = vm_mem[program[vm_eip + 3]];
              ops.op2 = vm_mem[program[vm_eip + 4]];
              vm_eip += 5;
            }
          }
        }
        vm_mem[dest] = ops.op1 - ops.op2;
        result_value = vm_mem[dest];
        goto continue;
      case mul:
        flag = program[vm_eip + 1];
        dest = program[vm_eip + 2];
        if ( flag == op1_is_ptr )
        {
          ops.op1 = vm_mem[program[vm_eip + 3]];
          ops.op2 = *&program[vm_eip + 4];
          vm_eip += 8;
        }
        else
        {
          if ( flag > op1_is_ptr )
          {
            if ( flag == op2_is_ptr )
            {
              ops.op1 = *&program[vm_eip + 3];
              ops.op2 = vm_mem[program[vm_eip + 7]];
              vm_eip += 8;
            }
            else
            {
              if ( flag == no_ptr )
              {
                ops.op1 = *&program[vm_eip + 3];
                ops.op2 = *&program[vm_eip + 7];
                vm_eip += 11;
              }
            }
          }
          else
          {
            if ( !flag )
            {
              ops.op1 = vm_mem[program[vm_eip + 3]];
              ops.op2 = vm_mem[program[vm_eip + 4]];
              vm_eip += 5;
            }
          }
        }
        vm_mem[dest] = ops.op2 * ops.op1;
        result_value = vm_mem[dest];
        goto continue;
      case div:                                 // with division, the operands are different
                                                // we have [flag][dest][% dest][op1][op2]
        flag = program[vm_eip + 1];
        dest = program[vm_eip + 2];
        ops.op1 = program[vm_eip + 3];
        if ( flag == op1_is_ptr )
        {
          ops.op2 = vm_mem[program[vm_eip + 4]];
          op2 = *&program[vm_eip + 5];
          vm_eip += 8;
        }
        else
        {
          if ( flag > op1_is_ptr )
          {
            if ( flag == op2_is_ptr )
            {
              ops.op2 = *&program[vm_eip + 4];
              op2 = vm_mem[program[vm_eip + 8]];
              vm_eip += 8;
            }
            else
            {
              if ( flag == no_ptr )
              {
                ops.op2 = *&program[vm_eip + 4];
                op2 = *&program[vm_eip + 8];
                vm_eip += 11;
              }
            }
          }
          else
          {
            if ( !flag )
            {
              ops.op2 = vm_mem[program[vm_eip + 4]];
              op2 = vm_mem[program[vm_eip + 5]];
              vm_eip += 5;
            }
          }
        }
        vm_mem[dest] = (*&ops >> 32) / op2;
        result_value = vm_mem[dest];
        vm_mem[ops.op1] = (*&ops >> 32) % op2;
        goto continue;
      case xor:3Ah
        flag = program[vm_eip + 1];
        dest = program[vm_eip + 2];
        if ( flag == op1_is_ptr )
        {
          ops.op1 = vm_mem[program[vm_eip + 3]];
          ops.op2 = *&program[vm_eip + 4];
          vm_eip += 8;
        }
        else
        {
          if ( flag > op1_is_ptr )
          {
            if ( flag == op2_is_ptr )
            {
              ops.op1 = *&program[vm_eip + 3];
              ops.op2 = vm_mem[program[vm_eip + 7]];
              vm_eip += 8;
            }
            else
            {
              if ( flag == no_ptr )
              {
                ops.op1 = *&program[vm_eip + 3];
                ops.op2 = *&program[vm_eip + 7];
                vm_eip += 11;
              }
            }
          }
          else
          {
            if ( !flag )                        // both_ptr
            {
              ops.op1 = vm_mem[program[vm_eip + 3]];
              ops.op2 = vm_mem[program[vm_eip + 4]];
              vm_eip += 5;
            }
          }
        }
        vm_mem[dest] = ops.op2 ^ ops.op1;
        result_value = vm_mem[dest];
        goto continue;
      case and:
        flag = program[vm_eip + 1];
        dest = program[vm_eip + 2];
        if ( flag == 1 )
        {
          ops.op1 = vm_mem[program[vm_eip + 3]];
          ops.op2 = *&program[vm_eip + 4];
          vm_eip += 8;
        }
        else
        {
          if ( flag > 1 )
          {
            if ( flag == 2 )
            {
              ops.op1 = *&program[vm_eip + 3];
              ops.op2 = vm_mem[program[vm_eip + 7]];
              vm_eip += 8;
            }
            else
            {
              if ( flag == 4 )
              {
                ops.op1 = *&program[vm_eip + 3];
                ops.op2 = *&program[vm_eip + 7];
                vm_eip += 11;
              }
            }
          }
          else
          {
            if ( !flag )
            {
              ops.op1 = vm_mem[program[vm_eip + 3]];
              ops.op2 = vm_mem[program[vm_eip + 4]];
              vm_eip += 5;
            }
          }
        }
        vm_mem[dest] = ops.op2 & ops.op1;
        result_value = vm_mem[dest];
        goto continue;
      case or:
        flag = program[vm_eip + 1];
        dest = program[vm_eip + 2];
        if ( flag == 1 )
        {
          ops.op1 = vm_mem[program[vm_eip + 3]];
          ops.op2 = *&program[vm_eip + 4];
          vm_eip += 8;
        }
        else
        {
          if ( flag > 1 )
          {
            if ( flag == 2 )
            {
              ops.op1 = *&program[vm_eip + 3];
              ops.op2 = vm_mem[program[vm_eip + 7]];
              vm_eip += 8;
            }
            else
            {
              if ( flag == 4 )
              {
                ops.op1 = *&program[vm_eip + 3];
                ops.op2 = *&program[vm_eip + 7];
                vm_eip += 11;
              }
            }
          }
          else
          {
            if ( !flag )
            {
              ops.op1 = vm_mem[program[vm_eip + 3]];
              ops.op2 = vm_mem[program[vm_eip + 4]];
              vm_eip += 5;
            }
          }
        }
        vm_mem[dest] = ops.op2 | ops.op1;
        result_value = vm_mem[dest];
        goto continue;
      case shl:
        flag = program[vm_eip + 1];
        dest = program[vm_eip + 2];
        if ( flag == 1 )
        {
          ops.op1 = vm_mem[program[vm_eip + 3]];
          ops.op2 = *&program[vm_eip + 4];
          vm_eip += 8;
        }
        else
        {
          if ( flag > 1 )
          {
            if ( flag == 2 )
            {
              ops.op1 = *&program[vm_eip + 3];
              ops.op2 = vm_mem[program[vm_eip + 7]];
              vm_eip += 8;
            }
            else
            {
              if ( flag == 4 )
              {
                ops.op1 = *&program[vm_eip + 3];
                ops.op2 = *&program[vm_eip + 7];
                vm_eip += 11;
              }
            }
          }
          else
          {
            if ( !flag )
            {
              ops.op1 = vm_mem[program[vm_eip + 3]];
              ops.op2 = vm_mem[program[vm_eip + 4]];
              vm_eip += 5;
            }
          }
        }
        vm_mem[dest] = ops.op1 << SLOBYTE(ops.op2);
        result_value = vm_mem[dest];
        goto continue;
      case shr:
        flag = program[vm_eip + 1];
        dest = program[vm_eip + 2];
        if ( flag == 1 )
        {
          ops.op1 = vm_mem[program[vm_eip + 3]];
          ops.op2 = *&program[vm_eip + 4];
          vm_eip += 8;
        }
        else
        {
          if ( flag > 1 )
          {
            if ( flag == 2 )
            {
              ops.op1 = *&program[vm_eip + 3];
              ops.op2 = vm_mem[program[vm_eip + 7]];
              vm_eip += 8;
            }
            else
            {
              if ( flag == 4 )
              {
                ops.op1 = *&program[vm_eip + 3];
                ops.op2 = *&program[vm_eip + 7];
                vm_eip += 11;
              }
            }
          }
          else
          {
            if ( !flag )
            {
              ops.op1 = vm_mem[program[vm_eip + 3]];
              ops.op2 = vm_mem[program[vm_eip + 4]];
              vm_eip += 5;
            }
          }
        }
        vm_mem[dest] = ops.op1 >> SLOBYTE(ops.op2);
        result_value = vm_mem[dest];
        goto continue;
      case test:
        dest = program[vm_eip + 1];
        ops.op1 = vm_mem[program[vm_eip + 2]];
        vm_eip += 3;
        vm_mem[dest] = ops.op1 == 0;
        result_value = vm_mem[dest];
        goto continue;
      case neg:
        dest = program[vm_eip + 1];
        ops.op1 = vm_mem[program[vm_eip + 2]];
        vm_eip += 3;
        vm_mem[dest] = -ops.op1;
        result_value = vm_mem[dest];
        goto continue;
      case not:
        dest = program[vm_eip + 1];
        ops.op1 = vm_mem[program[vm_eip + 2]];
        vm_eip += 3;
        vm_mem[dest] = ~ops.op1;
        result_value = vm_mem[dest];
        goto continue;
      case jmp|0x1:
        op1 = *&program[vm_eip + 1];
        --something_p;
        *(program + something_p) = vm_eip + 5;
        vm_eip = op1;
        goto continue;
      case jmp:
        op1 = *&program[vm_eip + 1];
        vm_eip = op1;
        goto continue;
      case jnz:
        op1 = *&program[vm_eip + 1];
        if ( result_value )
          tmp1 = vm_eip + 5;
        else
          tmp1 = op1;
        vm_eip = tmp1;
        goto continue;
      case jlz:
        op1 = *&program[vm_eip + 1];
        if ( result_value < 0 )
          tmp2 = op1;
        else
          tmp2 = vm_eip + 5;
        vm_eip = tmp2;
        goto continue;
      case jle:
        op1 = *&program[vm_eip + 1];
        if ( result_value <= 0 )
          tmp3 = op1;
        else
          tmp3 = vm_eip + 5;
        vm_eip = tmp3;
        goto continue;
      case jgz:
        op1 = *&program[vm_eip + 1];
        if ( result_value > 0 )
          tmp4 = op1;
        else
          tmp4 = vm_eip + 5;
        vm_eip = tmp4;
        goto continue;
      case jge:
        op1 = *&program[vm_eip + 1];
        if ( result_value >= 0 )
          tmp5 = op1;
        else
          tmp5 = vm_eip + 5;
        vm_eip = tmp5;
        goto continue;
      case jz:
        op1 = *&program[vm_eip + 1];
        if ( result_value )
          tmp6 = op1;
        else
          tmp6 = vm_eip + 5;
        vm_eip = tmp6;
        goto continue;
      case and_no_write:
        flag = program[vm_eip + 1];
        if ( flag == op1_is_ptr )
        {
          ops.op1 = vm_mem[program[vm_eip + 2]];
          ops.op2 = *&program[vm_eip + 3];
          vm_eip += 7;
        }
        else
        {
          if ( flag > op1_is_ptr )
          {
            if ( flag == op2_is_ptr )
            {
              ops.op1 = *&program[vm_eip + 2];
              ops.op2 = vm_mem[program[vm_eip + 6]];
              vm_eip += 7;
            }
            else
            {
              if ( flag == no_ptr )
              {
                ops.op1 = *&program[vm_eip + 2];
                ops.op2 = *&program[vm_eip + 6];
                vm_eip += 10;
              }
            }
          }
          else
          {
            if ( !flag )
            {
              ops.op1 = vm_mem[program[vm_eip + 2]];
              ops.op2 = vm_mem[program[vm_eip + 3]];
              vm_eip += 4;
            }
          }
        }
        result_value = ops.op1 & ops.op2;
        goto continue;
      case minus_no_write:
        flag = program[vm_eip + 1];
        if ( flag == 1 )
        {
          ops.op1 = vm_mem[program[vm_eip + 2]];
          ops.op2 = *&program[vm_eip + 3];
          vm_eip += 7;
        }
        else
        {
          if ( flag > 1 )
          {
            if ( flag == 2 )
            {
              ops.op1 = *&program[vm_eip + 2];
              ops.op2 = vm_mem[program[vm_eip + 6]];
              vm_eip += 7;
            }
            else
            {
              if ( flag == 4 )
              {
                ops.op1 = *&program[vm_eip + 2];
                ops.op2 = *&program[vm_eip + 6];
                vm_eip += 10;
              }
            }
          }
          else
          {
            if ( !flag )
            {
              ops.op1 = vm_mem[program[vm_eip + 2]];
              ops.op2 = vm_mem[program[vm_eip + 3]];
              vm_eip += 4;
            }
          }
        }
        result_value = ops.op1 - ops.op2;
        goto continue;
      case mov:
        flag = program[vm_eip + 1];
        if ( flag )
        {
          if ( flag == op1_is_ptr )
          {
            vm_mem[program[vm_eip + 2]] = *&program[vm_eip + 3];
            vm_eip += 7;
          }
        }
        else
        {
          vm_mem[program[vm_eip + 2]] = vm_mem[program[vm_eip + 3]];
          vm_eip += 4;
        }
        goto continue;
      case inc:
        dest = program[vm_eip + 1];
        ++vm_mem[dest];
        vm_eip += 2;
        goto continue;
      case dec:
        dest = program[vm_eip + 1];
        --vm_mem[dest];
        vm_eip += 2;
        goto continue;
      case set_from_code_offset:
        dest = program[vm_eip + 1];
        ops.op1 = program[vm_eip + 2];
        vm_eip += 3;
        vm_mem[dest] = *&program[vm_mem[ops.op1]];
        result_value = vm_mem[dest];
        goto continue;
      case change_code_from_offset:
        dest = program[vm_eip + 1];
        ops.op1 = program[vm_eip + 2];
        vm_eip += 3;
        tmp7 = &program[vm_mem[dest]];
        *tmp7 = vm_mem[ops.op1];
        result_value = *tmp7;
        goto continue;
      case change_code_from_offset|add:
        flag = program[vm_eip + 1];
        if ( flag )
        {
          dest = *&program[vm_eip + 2];
          vm_eip += 6;
        }
        else
        {
          dest = vm_mem[program[vm_eip + 2]];
          vm_eip += 3;
        }
        --something_p;
        *(program + something_p) = dest;
        goto continue;
      case set_from_something_p:
        dest = program[vm_eip + 1];
        vm_mem[dest] = *(program + something_p);
        ++something_p;
        vm_eip += 2;
        goto continue;
      case call:
        dest = program[vm_eip + 1];
        vm_mem[0] = vtable[dest](vm_mem);
        vm_eip += 2;
        goto continue;
      default:
        ++vm_eip;
        goto continue;
    }
  }
  return vm_mem[0];
}
// 804C060: using guessed type int (__cdecl *vtable[8])(int);
// 804898B: using guessed type int vm_mem[31];

//----- (08049C82) --------------------------------------------------------
int __cdecl main()
{
  int main_result; // eax@1
  int v1; // ecx@1
  char v2; // [sp+10h] [bp-88h]@1
  int v3; // [sp+8Ch] [bp-Ch]@1

  v3 = *MK_FP(__GS__, 20);
  memset(&v2, 0, 0x7Cu);
  run_vm(&v2);
  main_result = 0;
  if ( *MK_FP(__GS__, 20) != v3 )
    __stack_chk_fail(v1, *MK_FP(__GS__, 20) ^ v3);
  return main_result;
}
// 80484C0: using guessed type int __fastcall __stack_chk_fail(_DWORD, _DWORD);

//----- (08049CF0) --------------------------------------------------------
int *__cdecl get_ctors()
{
  init_proc();
  return &ctors;
}
// 804BF14: using guessed type int ctors;

//----- (08049D62) --------------------------------------------------------
void __cdecl deref_esp_to_ebx()
{
  ;
}

//----- (08049D70) --------------------------------------------------------
void (*__cdecl call_ctors())(void)
{
  void (*result)(void); // eax@1
  int *v1; // ebx@2

  result = ctors;
  if ( ctors != -1 )
  {
    v1 = &ctors;
    do
    {
      --v1;
      result();
      result = *v1;
    }
    while ( *v1 != -1 );
  }
  return result;
}
// 804BF14: using guessed type int ctors;

//----- (08049D9C) --------------------------------------------------------
void __cdecl term_proc()
{
  call_dtors();
}

#error "There were 1 decompilation failure(s) on 31 function(s)"
